<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
 </head>
 <body>
  <div aria-label="related navigation" class="related" role="navigation">
   <h3>
    Navigation
   </h3>
   <ul>
    <li>
     <img alt="" src="../_static/py.png" style="vertical-align: middle; margin-top: -1px"/>
    </li>
    <li class="right">
     |
    </li>
   </ul>
  </div>
  <div class="document">
   <div class="documentwrapper">
    <div class="bodywrapper">
     <div class="body" role="main">
      <div class="section" id="module-ast">
       <h1>
        — Abstract Syntax Trees
       </h1>
       <p>
        <strong>
         Source code:
        </strong>
       </p>
       <p>
        The  module helps Python applications to process trees of the Python abstract syntax grammar.  The abstract syntax itself might change with each Python release; this module helps to find out programmatically what the current grammar looks like.
       </p>
       <p>
        An abstract syntax tree can be generated by passing  as a flag to the  built-in function, or using the  helper provided in this module.  The result will be a tree of objects whose classes all inherit from  .  An abstract syntax tree can be compiled into a Python code object using the built-in  function.
       </p>
       <div class="section" id="node-classes">
        <h2>
         Node classes
        </h2>
        <dl class="class">
         <dt id="ast.AST">
          <em class="property">
           class
          </em>
          <code class="sig-prename descclassname">
           ast.
          </code>
          <code class="sig-name descname">
           AST
          </code>
         </dt>
         <dd>
          <p>
           This is the base of all AST node classes.  The actual node classes are derived from the  file, which is reproduced  .  They are defined in the  C module and re-exported in  .
          </p>
          <p>
           There is one class defined for each left-hand side symbol in the abstract grammar (for example,  or  ).  In addition, there is one class defined for each constructor on the right-hand side; these classes inherit from the classes for the left-hand side trees.  For example,  inherits from  .  For production rules with alternatives (aka “sums”), the left-hand side class is abstract: only instances of specific constructor nodes are ever created.
          </p>
          <dl class="attribute">
           <dt id="ast.AST._fields">
            <code class="sig-name descname">
             _fields
            </code>
           </dt>
           <dd>
            <p>
             Each concrete class has an attribute  which gives the names of all child nodes.
            </p>
            <p>
             Each instance of a concrete class has one attribute for each child node, of the type as defined in the grammar.  For example,  instances have an attribute  of type  .
            </p>
            <p>
             If these attributes are marked as optional in the grammar (using a question mark), the value might be  .  If the attributes can have zero-or-more values (marked with an asterisk), the values are represented as Python lists.  All possible attributes must be present and have valid values when compiling an AST with  .
            </p>
           </dd>
          </dl>
          <dl class="attribute">
           <dt id="ast.AST.lineno">
            <code class="sig-name descname">
             lineno
            </code>
           </dt>
           <dt id="ast.AST.col_offset">
            <code class="sig-name descname">
             col_offset
            </code>
           </dt>
           <dt id="ast.AST.end_lineno">
            <code class="sig-name descname">
             end_lineno
            </code>
           </dt>
           <dt id="ast.AST.end_col_offset">
            <code class="sig-name descname">
             end_col_offset
            </code>
           </dt>
           <dd>
            <p>
             Instances of  and  subclasses have  ,  ,  , and  attributes.  The  and  are the first and last line numbers of source text span (1-indexed so the first line is line 1) and the  and  are the corresponding UTF-8 byte offsets of the first and last tokens that generated the node. The UTF-8 offset is recorded because the parser uses UTF-8 internally.
            </p>
            <p>
             Note that the end positions are not required by the compiler and are therefore optional. The end offset is
             <em>
              after
             </em>
             the last symbol, for example one can get the source segment of a one-line expression node using  .
            </p>
           </dd>
          </dl>
          <p>
           The constructor of a class  parses its arguments as follows:
          </p>
          <ul class="simple">
           <li>
            <p>
             If there are positional arguments, there must be as many as there are items in  ; they will be assigned as attributes of these names.
            </p>
           </li>
           <li>
            <p>
             If there are keyword arguments, they will set the attributes of the same names to the given values.
            </p>
           </li>
          </ul>
          <p>
           For example, to create and populate an  node, you could use
          </p>
          <p>
           or the more compact
          </p>
         </dd>
        </dl>
        <div class="versionchanged">
         <p>
          Class  is now used for all constants.
         </p>
        </div>
        <div class="deprecated">
         <p>
          Old classes  ,  ,  ,  and  are still available, but they will be removed in future Python releases.  In the meanwhile, instantiating them will return an instance of a different class.
         </p>
        </div>
       </div>
       <div class="section" id="abstract-grammar">
        <h2>
         Abstract Grammar
        </h2>
        <p>
         The abstract grammar is currently defined as follows:
        </p>
        <div class="highlight-none notranslate">
         <div class="highlight">
          <pre>-- ASDL's 5 builtin types are: -- identifier, int, string, object, constant  module Python { mod = Module(stmt* body, type_ignore *type_ignores) | Interactive(stmt* body) | Expression(expr body) | FunctionType(expr* argtypes, expr returns)  -- not really an actual node but useful in Jython's typesystem. | Suite(stmt* body)  stmt = FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment) | AsyncFunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment)  | ClassDef(identifier name, expr* bases, keyword* keywords, stmt* body, expr* decorator_list) | Return(expr? value)  | Delete(expr* targets) | Assign(expr* targets, expr value, string? type_comment) | AugAssign(expr target, operator op, expr value) -- 'simple' indicates that we annotate simple name without parens | AnnAssign(expr target, expr annotation, expr? value, int simple)  -- use 'orelse' because else is a keyword in target languages | For(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment) | AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment) | While(expr test, stmt* body, stmt* orelse) | If(expr test, stmt* body, stmt* orelse) | With(withitem* items, stmt* body, string? type_comment) | AsyncWith(withitem* items, stmt* body, string? type_comment)  | Raise(expr? exc, expr? cause) | Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody) | Assert(expr test, expr? msg)  | Import(alias* names) | ImportFrom(identifier? module, alias* names, int? level)  | Global(identifier* names) | Nonlocal(identifier* names) | Expr(expr value) | Pass | Break | Continue  -- XXX Jython will be different -- col_offset is the byte offset in the utf8 string the parser uses attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)  -- BoolOp() can use left &amp; right? expr = BoolOp(boolop op, expr* values) | NamedExpr(expr target, expr value) | BinOp(expr left, operator op, expr right) | UnaryOp(unaryop op, expr operand) | Lambda(arguments args, expr body) | IfExp(expr test, expr body, expr orelse) | Dict(expr* keys, expr* values) | Set(expr* elts) | ListComp(expr elt, comprehension* generators) | SetComp(expr elt, comprehension* generators) | DictComp(expr key, expr value, comprehension* generators) | GeneratorExp(expr elt, comprehension* generators) -- the grammar constrains where yield expressions can occur | Await(expr value) | Yield(expr? value) | YieldFrom(expr value) -- need sequences for compare to distinguish between -- x &lt; 4 &lt; 3 and (x &lt; 4) &lt; 3 | Compare(expr left, cmpop* ops, expr* comparators) | Call(expr func, expr* args, keyword* keywords) | FormattedValue(expr value, int? conversion, expr? format_spec) | JoinedStr(expr* values) | Constant(constant value, string? kind)  -- the following expression can appear in assignment context | Attribute(expr value, identifier attr, expr_context ctx) | Subscript(expr value, slice slice, expr_context ctx) | Starred(expr value, expr_context ctx) | Name(identifier id, expr_context ctx) | List(expr* elts, expr_context ctx) | Tuple(expr* elts, expr_context ctx)  -- col_offset is the byte offset in the utf8 string the parser uses attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)  expr_context = Load | Store | Del | AugLoad | AugStore | Param  slice = Slice(expr? lower, expr? upper, expr? step) | ExtSlice(slice* dims) | Index(expr value)  boolop = And | Or  operator = Add | Sub | Mult | MatMult | Div | Mod | Pow | LShift | RShift | BitOr | BitXor | BitAnd | FloorDiv  unaryop = Invert | Not | UAdd | USub  cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn  comprehension = (expr target, expr iter, expr* ifs, int is_async)  excepthandler = ExceptHandler(expr? type, identifier? name, stmt* body) attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)  arguments = (arg* posonlyargs, arg* args, arg? vararg, arg* kwonlyargs, expr* kw_defaults, arg? kwarg, expr* defaults)  arg = (identifier arg, expr? annotation, string? type_comment) attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)  -- keyword arguments supplied to call (NULL identifier for **kwargs) keyword = (identifier? arg, expr value)  -- import name with optional 'as' alias. alias = (identifier name, identifier? asname)  withitem = (expr context_expr, expr? optional_vars)  type_ignore = TypeIgnore(int lineno, string tag) } </pre>
         </div>
        </div>
       </div>
       <div class="section" id="ast-helpers">
        <h2>
         Helpers
        </h2>
        <p>
         Apart from the node classes, the  module defines these utility functions and classes for traversing abstract syntax trees:
        </p>
        <dl class="function">
         <dt id="ast.parse">
          <code class="sig-prename descclassname">
           ast.
          </code>
          <code class="sig-name descname">
           parse
          </code>
          <em class="sig-param">
           source
          </em>
          ,
          <em class="sig-param">
           filename='&lt;unknown&gt;'
          </em>
          ,
          <em class="sig-param">
           mode='exec'
          </em>
          ,
          <em class="sig-param">
           *
          </em>
          ,
          <em class="sig-param">
           type_comments=False
          </em>
          ,
          <em class="sig-param">
           feature_version=None
          </em>
         </dt>
         <dd>
          <p>
           Parse the source into an AST node.  Equivalent to  .
          </p>
          <p>
           If  is given, the parser is modified to check and return type comments as specified by
           <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484">
            <strong>
             PEP 484
            </strong>
           </a>
           and
           <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526">
            <strong>
             PEP 526
            </strong>
           </a>
           . This is equivalent to adding  to the flags passed to  .  This will report syntax errors for misplaced type comments.  Without this flag, type comments will be ignored, and the  field on selected AST nodes will always be  .  In addition, the locations of  comments will be returned as the  attribute of  (otherwise it is always an empty list).
          </p>
          <p>
           In addition, if  is  , the input syntax is modified to correspond to
           <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484">
            <strong>
             PEP 484
            </strong>
           </a>
           “signature type comments”, e.g.  .
          </p>
          <p>
           Also, setting  to a tuple  will attempt to parse using that Python version’s grammar. Currently  must equal to  .  For example, setting  will allow the use of  and  as variable names.  The lowest supported version is  ; the highest is  .
          </p>
          <div class="admonition warning">
           <p class="admonition-title">
            Warning
           </p>
           <p>
            It is possible to crash the Python interpreter with a sufficiently large/complex string due to stack depth limitations in Python’s AST compiler.
           </p>
          </div>
          <div class="versionchanged">
           <p>
            Added  ,  and  .
           </p>
          </div>
         </dd>
        </dl>
        <dl class="function">
         <dt id="ast.literal_eval">
          <code class="sig-prename descclassname">
           ast.
          </code>
          <code class="sig-name descname">
           literal_eval
          </code>
          <em class="sig-param">
           node_or_string
          </em>
         </dt>
         <dd>
          <p>
           Safely evaluate an expression node or a string containing a Python literal or container display.  The string or node provided may only consist of the following Python literal structures: strings, bytes, numbers, tuples, lists, dicts, sets, booleans, and  .
          </p>
          <p>
           This can be used for safely evaluating strings containing Python values from untrusted sources without the need to parse the values oneself.  It is not capable of evaluating arbitrarily complex expressions, for example involving operators or indexing.
          </p>
          <div class="admonition warning">
           <p class="admonition-title">
            Warning
           </p>
           <p>
            It is possible to crash the Python interpreter with a sufficiently large/complex string due to stack depth limitations in Python’s AST compiler.
           </p>
          </div>
          <div class="versionchanged">
           <p>
            Now allows bytes and set literals.
           </p>
          </div>
         </dd>
        </dl>
        <dl class="function">
         <dt id="ast.get_docstring">
          <code class="sig-prename descclassname">
           ast.
          </code>
          <code class="sig-name descname">
           get_docstring
          </code>
          <em class="sig-param">
           node
          </em>
          ,
          <em class="sig-param">
           clean=True
          </em>
         </dt>
         <dd>
          <p>
           Return the docstring of the given
           <em>
            node
           </em>
           (which must be a  ,  ,  , or  node), or  if it has no docstring. If
           <em>
            clean
           </em>
           is true, clean up the docstring’s indentation with  .
          </p>
          <div class="versionchanged">
           <p>
            is now supported.
           </p>
          </div>
         </dd>
        </dl>
        <dl class="function">
         <dt id="ast.get_source_segment">
          <code class="sig-prename descclassname">
           ast.
          </code>
          <code class="sig-name descname">
           get_source_segment
          </code>
          <em class="sig-param">
           source
          </em>
          ,
          <em class="sig-param">
           node
          </em>
          ,
          <em class="sig-param">
           *
          </em>
          ,
          <em class="sig-param">
           padded=False
          </em>
         </dt>
         <dd>
          <p>
           Get source code segment of the
           <em>
            source
           </em>
           that generated
           <em>
            node
           </em>
           . If some location information (  ,  ,  , or  ) is missing, return  .
          </p>
          <p>
           If
           <em>
            padded
           </em>
           is  , the first line of a multi-line statement will be padded with spaces to match its original position.
          </p>
         </dd>
        </dl>
        <dl class="function">
         <dt id="ast.fix_missing_locations">
          <code class="sig-prename descclassname">
           ast.
          </code>
          <code class="sig-name descname">
           fix_missing_locations
          </code>
          <em class="sig-param">
           node
          </em>
         </dt>
         <dd>
          <p>
           When you compile a node tree with  , the compiler expects  and  attributes for every node that supports them.  This is rather tedious to fill in for generated nodes, so this helper adds these attributes recursively where not already set, by setting them to the values of the parent node.  It works recursively starting at
           <em>
            node
           </em>
           .
          </p>
         </dd>
        </dl>
        <dl class="function">
         <dt id="ast.increment_lineno">
          <code class="sig-prename descclassname">
           ast.
          </code>
          <code class="sig-name descname">
           increment_lineno
          </code>
          <em class="sig-param">
           node
          </em>
          ,
          <em class="sig-param">
           n=1
          </em>
         </dt>
         <dd>
          <p>
           Increment the line number and end line number of each node in the tree starting at
           <em>
            node
           </em>
           by
           <em>
            n
           </em>
           . This is useful to “move code” to a different location in a file.
          </p>
         </dd>
        </dl>
        <dl class="function">
         <dt id="ast.copy_location">
          <code class="sig-prename descclassname">
           ast.
          </code>
          <code class="sig-name descname">
           copy_location
          </code>
          <em class="sig-param">
           new_node
          </em>
          ,
          <em class="sig-param">
           old_node
          </em>
         </dt>
         <dd>
          <p>
           Copy source location (  ,  ,  , and  ) from
           <em>
            old_node
           </em>
           to
           <em>
            new_node
           </em>
           if possible, and return
           <em>
            new_node
           </em>
           .
          </p>
         </dd>
        </dl>
        <dl class="function">
         <dt id="ast.iter_fields">
          <code class="sig-prename descclassname">
           ast.
          </code>
          <code class="sig-name descname">
           iter_fields
          </code>
          <em class="sig-param">
           node
          </em>
         </dt>
         <dd>
          <p>
           Yield a tuple of  for each field in  that is present on
           <em>
            node
           </em>
           .
          </p>
         </dd>
        </dl>
        <dl class="function">
         <dt id="ast.iter_child_nodes">
          <code class="sig-prename descclassname">
           ast.
          </code>
          <code class="sig-name descname">
           iter_child_nodes
          </code>
          <em class="sig-param">
           node
          </em>
         </dt>
         <dd>
          <p>
           Yield all direct child nodes of
           <em>
            node
           </em>
           , that is, all fields that are nodes and all items of fields that are lists of nodes.
          </p>
         </dd>
        </dl>
        <dl class="function">
         <dt id="ast.walk">
          <code class="sig-prename descclassname">
           ast.
          </code>
          <code class="sig-name descname">
           walk
          </code>
          <em class="sig-param">
           node
          </em>
         </dt>
         <dd>
          <p>
           Recursively yield all descendant nodes in the tree starting at
           <em>
            node
           </em>
           (including
           <em>
            node
           </em>
           itself), in no specified order.  This is useful if you only want to modify nodes in place and don’t care about the context.
          </p>
         </dd>
        </dl>
        <dl class="class">
         <dt id="ast.NodeVisitor">
          <em class="property">
           class
          </em>
          <code class="sig-prename descclassname">
           ast.
          </code>
          <code class="sig-name descname">
           NodeVisitor
          </code>
         </dt>
         <dd>
          <p>
           A node visitor base class that walks the abstract syntax tree and calls a visitor function for every node found.  This function may return a value which is forwarded by the  method.
          </p>
          <p>
           This class is meant to be subclassed, with the subclass adding visitor methods.
          </p>
          <dl class="method">
           <dt id="ast.NodeVisitor.visit">
            <code class="sig-name descname">
             visit
            </code>
            <em class="sig-param">
             node
            </em>
           </dt>
           <dd>
            <p>
             Visit a node.  The default implementation calls the method called  where
             <em>
              classname
             </em>
             is the name of the node class, or  if that method doesn’t exist.
            </p>
           </dd>
          </dl>
          <dl class="method">
           <dt id="ast.NodeVisitor.generic_visit">
            <code class="sig-name descname">
             generic_visit
            </code>
            <em class="sig-param">
             node
            </em>
           </dt>
           <dd>
            <p>
             This visitor calls  on all children of the node.
            </p>
            <p>
             Note that child nodes of nodes that have a custom visitor method won’t be visited unless the visitor calls  or visits them itself.
            </p>
           </dd>
          </dl>
          <p>
           Don’t use the  if you want to apply changes to nodes during traversal.  For this a special visitor exists (  ) that allows modifications.
          </p>
          <div class="deprecated">
           <p>
            Methods  ,  ,  ,  and  are deprecated now and will not be called in future Python versions.  Add the  method to handle all constant nodes.
           </p>
          </div>
         </dd>
        </dl>
        <dl class="class">
         <dt id="ast.NodeTransformer">
          <em class="property">
           class
          </em>
          <code class="sig-prename descclassname">
           ast.
          </code>
          <code class="sig-name descname">
           NodeTransformer
          </code>
         </dt>
         <dd>
          <p>
           A  subclass that walks the abstract syntax tree and allows modification of nodes.
          </p>
          <p>
           The  will walk the AST and use the return value of the visitor methods to replace or remove the old node.  If the return value of the visitor method is  , the node will be removed from its location, otherwise it is replaced with the return value.  The return value may be the original node in which case no replacement takes place.
          </p>
          <p>
           Here is an example transformer that rewrites all occurrences of name lookups (  ) to  :
          </p>
          <p>
           Keep in mind that if the node you’re operating on has child nodes you must either transform the child nodes yourself or call the  method for the node first.
          </p>
          <p>
           For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node.
          </p>
          <p>
           If  introduces new nodes (that weren’t part of original tree) without giving them location information (such as  ),  should be called with the new sub-tree to recalculate the location information:
          </p>
          <p>
           Usually you use the transformer like this:
          </p>
         </dd>
        </dl>
        <dl class="function">
         <dt id="ast.dump">
          <code class="sig-prename descclassname">
           ast.
          </code>
          <code class="sig-name descname">
           dump
          </code>
          <em class="sig-param">
           node
          </em>
          ,
          <em class="sig-param">
           annotate_fields=True
          </em>
          ,
          <em class="sig-param">
           include_attributes=False
          </em>
         </dt>
         <dd>
          <p>
           Return a formatted dump of the tree in
           <em>
            node
           </em>
           .  This is mainly useful for debugging purposes.  If
           <em>
            annotate_fields
           </em>
           is true (by default), the returned string will show the names and the values for fields. If
           <em>
            annotate_fields
           </em>
           is false, the result string will be more compact by omitting unambiguous field names.  Attributes such as line numbers and column offsets are not dumped by default.  If this is wanted,
           <em>
            include_attributes
           </em>
           can be set to true.
          </p>
         </dd>
        </dl>
        <div class="admonition seealso">
         <p class="admonition-title">
          See also
         </p>
         <p>
          , an external documentation resource, has good details on working with Python ASTs.
         </p>
        </div>
       </div>
      </div>
     </div>
    </div>
   </div>
   <div aria-label="main navigation" class="sphinxsidebar" role="navigation">
    <div class="sphinxsidebarwrapper">
     <ul>
      <li>
       <a class="reference internal" href="#">
        — Abstract Syntax Trees
       </a>
       <ul>
        <li>
         <a class="reference internal" href="#ast-helpers">
          Helpers
         </a>
        </li>
       </ul>
      </li>
     </ul>
     <h4>
      Previous topic
     </h4>
     <p class="topless">
      <a href="parser.html" title="previous chapter">
       — Access Python parse trees
      </a>
     </p>
     <h4>
      Next topic
     </h4>
     <p class="topless">
      <a href="symtable.html" title="next chapter">
       — Access to the compiler’s symbol tables
      </a>
     </p>
     <div aria-label="source link" role="note">
      <h3>
       This Page
      </h3>
     </div>
    </div>
   </div>
  </div>
  <div aria-label="related navigation" class="related" role="navigation">
   <h3>
    Navigation
   </h3>
   <ul>
    <li>
     <img alt="" src="../_static/py.png" style="vertical-align: middle; margin-top: -1px"/>
    </li>
    <li class="right">
     |
    </li>
   </ul>
  </div>
  <div class="footer">
   ©  2001-2020, Python Software Foundation.
   <br/>
   The Python Software Foundation is a non-profit corporation.
   <br/>
   <br/>
   Last updated on Mar 18, 2020.  ?
   <br/>
   Created using  2.3.1.
  </div>
 </body>
</html>